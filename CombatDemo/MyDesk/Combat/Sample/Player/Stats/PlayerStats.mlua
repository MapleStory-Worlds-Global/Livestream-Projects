@Struct
script PlayerStats extends CharacterStats

	property table addedStats = {}

	property number jobClassValue = 0

	property table baseStats = {}

	property number mastery = 20

	property table percentageStats = {}

	property table finalStats = {}

	property number critChance = 5

	property number addedDefense = 0

	method void IncreaseStat(integer type, integer value)
		self.baseStats[type] += value
		self:CalculateClassValue()
		self:CalculateDefense()
		--TODO: When Saving is implemented, save the new class value to DB. 
	end

	method void Init(Entity context)
		__base:Init(context)
		local player = context.PlayerInfoComponent
		self.level = player.level
		--TODO: When Saving is implemented, load from DB instead of setting to base stats every time. 
		self:SetToBaseStats()
		self:CalculateClassValue()
		self:CalculateDefense()
		self:SetLevelAdvantagePcts()
	end

	method void SetToBaseStats()
		self.hp = 50
		self.mp = 50
		self.mastery = 20
		self.defense = 5
		for i = 1, _PlayerStatsEnum.MAX-1 do 
			self.baseStats[i] = _UtilLogic:RandomIntegerRange(5,9) 
			self.addedStats[i] = 0
			self.percentageStats[i] = 0
			self.finalStats[i] = 0
		end
	end

	method number GetUpperDamageRange(CharacterStats defender)
		return math.floor(self:GetLevelAdvantageMultiplier(defender.level) * self.jobClassValue)
	end

	method number GetLowerDamageRange(CharacterStats defender, number upperRange)
		return math.floor(upperRange * (self.mastery/100))
	end

	method void CalculateClassValue()
		--TODO: Allow Dynamic Setting of Primary/Secondary Stat Values based on Job Class. 
		local primary = self:GetStat(_PlayerStatsEnum.STR)
		local secondary = self:GetStat(_PlayerStatsEnum.DEX)
		self.jobClassValue = primary * 4 + secondary
	end

	method number GetStat(integer type)
		return math.floor((self.baseStats[type] + self.addedStats[type]) * (1 + self.percentageStats[type]/100) + self.finalStats[type])
	end

	method number GetLevelAdvantageMultiplier(integer level)
		local levelDiff = self.level - level
		local index = math.clamp(levelDiff + 41,1,46)
		return self._T.levelAdvantagePcts[index] 
	end

	method void SetLevelAdvantagePcts()
		local pcts = {
			0,
			.03,
			.05,
			.07,
			.1,
			.13,
			.15,
			.17,
			.2,
			.23,
			.25,
			.27,
			.3,
			.33,
			.35,
			.37,
			.4,
			.43,
			.45,
			.47,
			.5,
			.53,
			.55,
			.57,
			.6,
			.63,
			.65,
			.67,
			.7,
			.73,
			.75,
			.77,
			.8,
			.83,
			.85,
			.87,
			.918,
			.9672,
			1.07,
			1.0584,
			1.1,
			1.12,
			1.14,
			1.16,
			1.18,
			1.2
		}
		
		self._T.levelAdvantagePcts = pcts
	end

	method number GetPower(CharacterStats defender)
		local upperRange = self:GetUpperDamageRange(defender)
		local lowerRange = self:GetLowerDamageRange(defender, upperRange)
		
		return _UtilLogic:RandomIntegerRange(lowerRange, upperRange)
	end

	method number GainHP()
		--TODO: Beginners Gain 12-16 HP. Allow hp range selection based on class. 
		return _UtilLogic:RandomIntegerRange(50,70)
	end

	method number GainMP()
		--TODO: Beginners Gain 6-8 MP. Allow hp range selection based on class. 
		return _UtilLogic:RandomIntegerRange(4,6)
	end

	method void LevelUp()
		self.level += 1
		self.hp += self:GainHP()
		self.mp += self:GainMP()
	end

	method void CalculateDefense()
		self.finalDefense = (1.5 * self:GetStat(_PlayerStatsEnum.STR) + 0.4 * (self:GetStat(_PlayerStatsEnum.DEX) + self:GetStat(_PlayerStatsEnum.LUK)) + self.addedDefense) * (1 + self.defense/100)
	end

	method number GetUpperDefenseRange(integer level, number powerValue)
		local a = self:LevelDefenseAdvantageMultiplierA(level)
		local b = self:LevelDefenseAdvantageMultiplierB(level)
		local monsterAtt = powerValue
		local defense = self.finalDefense
		
		return math.floor(a * (monsterAtt - b * defense))
	end

	method number GetLowerDefenseRange(integer level, number powerValue)
		local a = self:LevelDefenseAdvantageMultiplierA(level)
		local b = self:LevelDefenseAdvantageMultiplierB(level)
		local monsterAtt = powerValue
		local defense = self.finalDefense
		
		return math.floor(a * (.85 * monsterAtt - b * defense))
	end

	method number LevelDefenseAdvantageMultiplierA(integer level)
		local levelDiff = self.level - level
		local finalA = 0
		if levelDiff > 0 then 
			local diffIndex = math.clamp(levelDiff,1,10)
			local valueTable = {
				.8425,
				.835,
				.8275,
				.82,
				.8125,
				.805,
				.7975,
				.79,
				.7825,
				.775
			}
			finalA = valueTable[diffIndex]
		elseif levelDiff >= -15 then 
			finalA = .85
		elseif levelDiff >= -20 then 
			finalA = .8575
		elseif levelDiff >= -25 then
			 finalA = .865
		elseif levelDiff >= -30 then
			 finalA = .8725
		else
			finalA = .88
		end 
		
		return finalA
	end

	method number LevelDefenseAdvantageMultiplierB(integer level)
		local levelDiff = self.level - level
		local index = math.clamp(levelDiff + 31,1,31)
		local valueTable = {
			.5,
			.52,
			.54,
			.56,
			.58,
			.6,
			.62,
			.64,
			.66,
			.68,
			.7,
			.72,
			.74,
			.76,
			.78,
			.8,
			.82,
			.84,
			.86,
			.88,
			.9,
			.91,
			.92,
			.93,
			.94,
			.95,
			.96,
			.97,
			.98,
			.99,
			1
		}
		
		return valueTable[index]
		
	end

	method number GetDamage(integer level, number powerValue)
		local upperRange = self:GetUpperDefenseRange(level, powerValue)
		local lowerRange = self:GetLowerDefenseRange(level, powerValue)
		
		return _UtilLogic:RandomIntegerRange(lowerRange, upperRange)
	end

	method table GetStats()
		local stats = {}
		for i = 1, _PlayerStatsEnum.MAX-1 do 
			stats[i] = self:GetStat(i)
		end
		
		return stats
	end

end